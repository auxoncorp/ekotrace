* Wire protocol evaluation
** Conclusion
The two reasonable candidates were Flatbuffers and LCM. We agreed that
flatbuffers has a bunch of complexity to solve problems that we don't have. LCM
will take a little work to whip into no_std shape (~2-3 days), but we're very
confident that we'll end up with something maintainable, debuggable, and well
suited to this problem space.

** Evaluation Criteria
We would like a general wire protocol to use for the tracing library, and other
things.

- Schema language
- rust support
- no_std rust support
  - Suitability
- Compatibility scheme
- mmap-ability
- familiarity
- RPC
- Simplicity

** Protobufs
- Schema language: .proto files.
- rust support: Yes.
- no_std rust support: Yes, in quick-protos
  - Suitability: Ok. It really wants an allocator.
- Compatibility scheme: Field numbers
- mmap-ability: No
- familiarity: High
- RPC: yes, via grpc, but it's way to complex for embedded use.
- Simplicity: medium-simple, for message encoding.

*** quick-protos
The devil we know, but nobody wants to use this anymore
*** New no_std implementation
Seems fairly approachable, but it wouldn't solve the fundamental problem, where
it's very natural to want to allocate Boxes and Vecs on the heap during
deserialization. Dealing with this gracefully would be the primary challenge.

** Cap'n proto
- Schema language: .capnp files.
- rust support: Yes. Looks pretty legit.
- no_std rust support: No
  - Suitability: So-so. There's a PR working on it, last active in August:
    https://github.com/capnproto/capnproto-rust/pull/138 but it's using the
    alloc and core_io crates, and they seem to be paying the price. The
    implementation is pretty complex overall. 

    - They do have an abstraction over the segment allocator. But they use Vecs
      and Boxes all over the place.
    - The Boxes are mostly about hooks: ClientHook, PipelineHook, RequestHook. I
      think this is rpc stuff, which could probably conditionally compiled out.
    - Vecs are used for dynamically allocated byte/word buffers in a number of
      places.

    The protocol design is generally very suitable for no_std operation.
- Compatibility scheme: Field numbers
- mmap-ability: Yes
- familiarity: Low
- RPC: yes
- Simplicity: It's pretty complex.

** Flatbuffers
- Schema language: .fbs
- rust support: Yes
- no_std rust support: No
  - Suitability: This looks very close. It uses no boxes. Vecs are used in
    FlatBufferBuilder, appears to be fixable. Doesn't use the io traits.
- Compatibility scheme: 
- mmap-ability: Yes
- familiarity: Low
- RPC: there's grpc integration, fwiw. Doesn't mean much to us.
- Simplicity: Looks to be simpler than cap'n proto.

** LCM
- Schema language: .lcm
- rust support: Yes
- no_std rust support: No
  - Suitability: lcm-rust has a lot of random deps: failure, regex, 'net2', log.
    Uses std::io traits. We'd basically have to extract the 'message' module and
    rework it with custom read/write traits. But, there's not much to it, so
    that appears to be pretty straightforward.
    
    We may be able to write a version that does in-place decoding,
    flatbuffers-style. It uses old-school network endianness, which is
    unfortunate.
- Compatibility: Messages have a schema hash for version checking, but no compatibility mechanism. 
- mmap-ability: No
- familiarity: Low
- RPC: They have a UDP broadcast thing. 
- Simplicity: It's very simple.

** SBE
- Quoth Zack: "No. Just no."
